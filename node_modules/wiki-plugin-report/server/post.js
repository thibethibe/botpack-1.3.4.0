"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
(function () {
  var Farm, Port, Site, Sufix, child, compose, enclose, fetchPage, findPaths, findPubs, findSchedule, flow, fold, fs, header, links, print, ready, report, sendmail;
  child = require('child_process');
  fs = require('fs');
  report = require('./report.js');
  print = function print() {
    var _console;
    return (_console = console).log.apply(_console, arguments);
  };

  // 0 * * * * (cd wiki/client/plugins/report; Port=:1111 /usr/local/bin/node post.js)
  Site = process.env.Site || null;
  Port = process.env.Port || '';
  if (!Site) {
    Farm = process.env.Farm || '../../../data/farm';
  }
  Sufix = process.env.Sufix || 'report';

  // Fetch data from wiki farm files
  findPaths = function findPaths(done) {
    if (Farm) {
      return child.exec("ls ".concat(Farm, "/*/pages/*-").concat(Sufix), function (err, stdout, stderr) {
        var i, len, path, ref, results, site, slug, x;
        ref = stdout.split(/\n/);
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          path = ref[i];
          if (path === '') {
            continue;
          }
          var _path$split$reverse = path.split('/').reverse();
          var _path$split$reverse2 = _slicedToArray(_path$split$reverse, 3);
          slug = _path$split$reverse2[0];
          x = _path$split$reverse2[1];
          site = _path$split$reverse2[2];
          results.push(done(path, site, slug));
        }
        return results;
      });
    } else {
      return child.exec("ls ../../../data/pages/*-".concat(Sufix), function (err, stdout, stderr) {
        var i, len, path, ref, results, slug;
        ref = stdout.split(/\n/);
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          path = ref[i];
          if (path === '') {
            continue;
          }
          var _path$split$reverse3 = path.split('/').reverse();
          var _path$split$reverse4 = _slicedToArray(_path$split$reverse3, 1);
          slug = _path$split$reverse4[0];
          results.push(done(path, Site, slug));
        }
        return results;
      });
    }
  };
  fetchPage = function fetchPage(path, done) {
    var text;
    return text = fs.readFile(path, 'utf8', function (err, text) {
      if (err) {
        return console.log(['fetchPage', path, err]);
      }
      return done(JSON.parse(text));
    });
  };
  findSchedule = function findSchedule(page) {
    var i, item, len, ref;
    ref = page.story;
    for (i = 0, len = ref.length; i < len; i++) {
      item = ref[i];
      if (item.type === 'report') {
        return report.parse(item.text);
      }
    }
    return null;
  };
  findPubs = function findPubs(done) {
    return findPaths(function (path, site, slug) {
      return fetchPage(path, function (page) {
        var i, issue, len, ref, results, schedule;
        if (schedule = findSchedule(page)) {
          results = [];
          for (i = 0, len = schedule.length; i < len; i++) {
            issue = schedule[i];
            if (issue.interval != null && ((ref = issue.recipients) != null ? ref.length : void 0)) {
              results.push(done({
                site: site,
                slug: slug,
                page: page,
                schedule: schedule,
                issue: issue
              }));
            } else {
              results.push(void 0);
            }
          }
          return results;
        }
      });
    });
  };

  // Compose summary from story and journal
  links = function links(text) {
    return text.replace(/\[(http.*?) +(.*?)\]/gi, "[$2]");
  };
  flow = function flow(text) {
    return text.replace(/\s+/g, ' ') + "\n";
  };
  fold = function fold(text) {
    // http://james.padolsey.com/javascript/wordwrap-for-javascript/
    return text.match(/.{1,50}(\s|$)|\S+?(\s|$)/g).join("\n");
  };
  compose = function compose(page, since) {
    var action, active, i, item, j, len, len1, ref, ref1, result;
    active = {};
    ref = page.journal;
    for (i = 0, len = ref.length; i < len; i++) {
      action = ref[i];
      if (action.date && action.date > since) {
        if (action.type === 'add') {
          active[action.id] = 'NEW';
        }
        if (action.type === 'edit' && !active[action.id]) {
          active[action.id] = 'UPDATE';
        }
      }
    }
    result = [];
    ref1 = page.story;
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      item = ref1[j];
      if (item.type === 'paragraph' && active[item.id]) {
        result.push(active[item.id]);
        result.push(fold(flow(links(item.text))));
      }
    }
    return result.join("\n");
  };
  ready = function ready(_ref) {
    var issue = _ref.issue,
      now = _ref.now,
      period = _ref.period;
    var lapse, thisIssue, window;
    window = period * 60 * 1000;
    thisIssue = report.advance(now, issue, 0);
    lapse = now.getTime() - thisIssue.getTime();
    return lapse < window;
  };

  // Hand off to sendmail for distribution
  header = function header(fields) {
    var k, v;
    return function () {
      var results;
      results = [];
      for (k in fields) {
        v = fields[k];
        results.push("".concat(k, ": ").concat(v));
      }
      return results;
    }().join("\n");
  };
  enclose = function enclose(_ref2) {
    var site = _ref2.site,
      slug = _ref2.slug,
      page = _ref2.page,
      issue = _ref2.issue,
      summary = _ref2.summary;
    return [header, {
      To: issue.recipients.join(", "),
      'Reply-to': issue.recipients.join(", "),
      Subject: "".concat(page.title, " (").concat(issue.interval, ")")
    }, "".concat(page.title, "\nPublished ").concat(issue.interval, " from Federated Wiki"), summary, "See details at\nhttp://".concat(site).concat(Port, "/").concat(slug, ".html")].join("\n\n");
  };
  sendmail = function sendmail(pub) {
    var output, send;
    output = [];
    send = child.spawn('/usr/sbin/sendmail', ['-fward@wiki.org', '-t']);
    send.stdin.write(pub.message);
    send.stdin.end();
    send.stderr.setEncoding('utf8');
    send.stderr.on('data', function (data) {
      return output.push(data);
    });
    return send.on('exit', function (code) {
      print("sent ".concat(pub.page.title, " (").concat(pub.issue.interval, "), code: ").concat(code));
      return print(output.join(''));
    });
  };

  // Main program loops over all publications
  findPubs(function (pub) {
    pub.now = new Date(2012, 12 - 1, 21, 0, 0, 3);
    pub.now = new Date();
    pub.period = 60;
    if (ready(pub)) {
      pub.summary = compose(pub.page, report.advance(pub.now, pub.issue, -1));
      if (pub.summary !== '') {
        pub.message = enclose(pub);
        return sendmail(pub);
      }
    }
  });
}).call(void 0);
//# sourceMappingURL=post.js.map
