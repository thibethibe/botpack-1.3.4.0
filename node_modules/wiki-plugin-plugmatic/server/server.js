"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
(function () {
  // plugmatic plugin, server-side component
  // These handlers are launched with the wiki server.
  var async, execFile, fs, github, glob, https, jsonfile, startServer;
  fs = require('fs');
  glob = require('glob');
  async = require('async');
  jsonfile = require('jsonfile');
  https = require('https');
  execFile = require('child_process').execFile;
  github = function github(path, done) {
    var e, options, req;
    options = {
      host: 'raw.githubusercontent.com',
      port: 443,
      method: 'GET',
      path: path
    };
    try {
      req = https.get(options, function (res) {
        var data;
        res.setEncoding('utf8');
        data = '';
        res.on('error', function () {
          return done(null);
        });
        res.on('timeout', function () {
          return done(null);
        });
        res.on('data', function (d) {
          return data += d;
        });
        return res.on('end', function () {
          return done(data);
        });
      });
      return req.on('error', function () {
        return done(null);
      });
    } catch (error) {
      e = error;
      return done(null);
    }
  };

  // http://www.sebastianseilund.com/nodejs-async-in-practice
  startServer = function startServer(params) {
    var _admin, app, argv, bundle, farm, info, path, plugmap, route, view;
    app = params.app;
    argv = params.argv;
    bundle = null;
    github('/fedwiki/wiki/master/package.json', function (data) {
      return bundle = {
        date: Date.now(),
        data: JSON.parse(data || '{"dependencies":{}}')
      };
    });
    route = function route(endpoint) {
      return "/plugin/plugmatic/".concat(endpoint);
    };
    path = function path(file) {
      return "".concat(argv.packageDir, "/").concat(file);
    };
    info = function info(file, done) {
      var authors, birth, factory, packagejson, pages, plugin, site;
      plugin = file.slice(12);
      site = {
        plugin: plugin
      };
      birth = function birth(cb) {
        return fs.stat(path("".concat(file, "/client/").concat(plugin, ".js")), function (err, stat) {
          var ref;
          site.birth = stat != null ? (ref = stat.birthtime) != null ? ref.getTime() : void 0 : void 0;
          return cb();
        });
      };
      pages = function pages(cb) {
        var _synopsis;
        _synopsis = function synopsis(slug, cb2) {
          return jsonfile.readFile(path("".concat(file, "/pages/").concat(slug)), {
            "throws": false
          }, function (err, page) {
            var ref, ref1, ref2, ref3, title;
            title = page.title || slug;
            _synopsis = ((ref = page.story) != null ? (ref1 = ref[0]) != null ? ref1.text : void 0 : void 0) || ((ref2 = page.story) != null ? (ref3 = ref2[1]) != null ? ref3.text : void 0 : void 0) || 'empty';
            return cb2(null, {
              file: file,
              slug: slug,
              title: title,
              synopsis: _synopsis
            });
          });
        };
        return fs.readdir(path("".concat(file, "/pages")), function (err, slugs) {
          return async.map(slugs || [], _synopsis, function (err, pages) {
            site.pages = pages;
            return cb();
          });
        });
      };
      packagejson = function packagejson(cb) {
        return jsonfile.readFile(path("".concat(file, "/package.json")), {
          "throws": false
        }, function (err, packagejson) {
          site["package"] = packagejson;
          return cb();
        });
      };
      factory = function factory(cb) {
        return jsonfile.readFile(path("".concat(file, "/factory.json")), {
          "throws": false
        }, function (err, factory) {
          site.factory = factory;
          return cb();
        });
      };
      authors = function authors(cb) {
        return fs.readFile(path("".concat(file, "/AUTHORS.txt")), 'utf-8', function (err, authors) {
          site.authors = authors;
          return cb();
        });
      };
      // persona = (cb) ->
      //   fs.readFile path("#{file}/status/persona.identity"),'utf8', (err, identity) ->
      //     site.persona = identity; cb()
      // openid = (cb) ->
      //   fs.readFile path("#{file}/status/open_id.identity"),'utf8', (err, identity) ->
      //     site.openid = identity; cb()
      return async.series([birth, authors, packagejson, factory, pages], function (err) {
        return done(null, site);
      });
    };
    plugmap = function plugmap(done) {
      return glob("wiki-plugin-*", {
        cwd: argv.packageDir
      }, function (err, files) {
        if (err) {
          return done(err, null);
        }
        return async.map(files || [], info, function (err, install) {
          if (err) {
            return done(err, null);
          }
          return done(null, install);
        });
      });
    };
    view = function view(plugin, done) {
      var pkg;
      if (/^\w+$/.test(plugin)) {
        pkg = "wiki-plugin-".concat(plugin);
        return execFile('npm', ['view', "".concat(pkg), '--json'], function (err, stdout, stderr) {
          var npm;
          try {
            npm = JSON.parse(stdout);
          } catch (error) {}
          return done(null, {
            plugin: plugin,
            pkg: pkg,
            npm: npm
          });
        });
      }
    };
    farm = function farm(req, res, next) {
      if (argv.f) {
        return next();
      } else {
        return res.status(404).send({
          error: 'service requires farm mode'
        });
      }
    };
    _admin = function admin(req, res, next) {
      var ref, ref1, ref2, ref3, user;
      if (app.securityhandler.isAdmin(req)) {
        return next();
      } else {
        if (!argv.admin) {
          _admin = "none specified";
        }
        if (!(((ref = req.session) != null ? (ref1 = ref.passport) != null ? ref1.user : void 0 : void 0) || ((ref2 = req.session) != null ? ref2.email : void 0) || ((ref3 = req.session) != null ? ref3.friend : void 0))) {
          user = "not logged in";
        }
        return res.status(403).send({
          error: 'service requires admin user',
          admin: _admin,
          user: user
        });
      }
    };
    app.get(route('page/:slug.json'), function (req, res) {
      return plugmap(function (err, install) {
        var i, j, k, len, len1, p, ref;
        for (j = 0, len = install.length; j < len; j++) {
          i = install[j];
          ref = i.pages;
          for (k = 0, len1 = ref.length; k < len1; k++) {
            p = ref[k];
            if (p.slug === req.params.slug) {
              return jsonfile.readFile(path("".concat(p.file, "/pages/").concat(p.slug)), {
                "throws": false
              }, function (err, page) {
                return res.json(page);
              });
            }
          }
        }
        return res.sendStatus(404);
      });
    });
    app.get(route('file/:file/slug/:slug'), function (req, res) {
      return jsonfile.readFile(path("".concat(req.params.file, "/pages/").concat(req.params.slug)), {
        "throws": false
      }, function (err, page) {
        if (err) {
          return res.sendStatus(404);
        } else {
          return res.json(page);
        }
      });
    });
    app.get(route('sitemap.json'), function (req, res) {
      return plugmap(function (err, install) {
        var _ref;
        var i;
        // http://stackoverflow.com/a/4631593
        return res.json((_ref = []).concat.apply(_ref, _toConsumableArray(function () {
          var j, len, results1;
          results1 = [];
          for (j = 0, len = install.length; j < len; j++) {
            i = install[j];
            results1.push(i.pages);
          }
          return results1;
        }())));
      });
    });
    app.get(route('plugins'), function (req, res) {
      return glob("wiki-plugin-*", {
        cwd: argv.packageDir
      }, function (err, files) {
        if (err) {
          return res.e(err);
        }
        return async.map(files || [], info, function (err, install) {
          if (err) {
            return res.e(err);
          }
          return res.json({
            install: install,
            bundle: bundle
          });
        });
      });
    });
    app.post(route('plugins'), function (req, res) {
      var installed, payload, published;
      payload = {
        bundle: bundle
      };
      installed = function installed(cb) {
        var files, plugin;
        files = function () {
          var j, len, ref, results1;
          ref = req.body.plugins || [];
          results1 = [];
          for (j = 0, len = ref.length; j < len; j++) {
            plugin = ref[j];
            results1.push("wiki-plugin-".concat(plugin));
          }
          return results1;
        }();
        return async.map(files || [], info, function (err, install) {
          payload.install = install;
          return cb();
        });
      };
      published = function published(cb) {
        return async.map(req.body.plugins || [], view, function (err, results) {
          payload.publish = results;
          return cb();
        });
      };
      return async.parallel([installed, published], function (err) {
        return res.json(payload);
      });
    });
    app.get(route('view/:pkg'), function (req, res) {
      var pkg;
      if (/^\w+$/.test(req.params.pkg)) {
        pkg = "wiki-plugin-".concat(req.params.pkg);
        res.setHeader('Content-Type', 'application/json');
        return execFile('npm', ['view', "".concat(pkg), '--json']).stdout.pipe(res);
      }
    });
    app.post(route('install'), _admin, function (req, res) {
      var pkg;
      if (/^\w+$/.test(req.body.plugin) && /^[\w.-]+$/.test(req.body.version)) {
        pkg = "wiki-plugin-".concat(req.body.plugin, "@").concat(req.body.version);
        console.log("plugmatic installing ".concat(pkg));
        return execFile('npm', ['install', "".concat(pkg), '--json'], {
          cwd: argv.packageDir + '/..'
        }, function (err, stdout, stderr) {
          var npm;
          try {
            npm = JSON.parse(stdout);
          } catch (error) {}
          if (err) {
            return res.status(400).json({
              error: 'server unable to install plugin',
              npm: npm,
              stderr: stderr
            });
          } else {
            return info("wiki-plugin-".concat(req.body.plugin), function (err, row) {
              return res.json({
                installed: req.body.version,
                npm: npm,
                stderr: stderr,
                row: row
              });
            });
          }
        });
      }
    });
    return app.post(route('restart'), _admin, function (req, res) {
      console.log('plugmatic exit to restart');
      res.sendStatus(200);
      return process.exit(0);
    });
  };
  module.exports = {
    startServer: startServer
  };
}).call(void 0);
//# sourceMappingURL=server.js.map
